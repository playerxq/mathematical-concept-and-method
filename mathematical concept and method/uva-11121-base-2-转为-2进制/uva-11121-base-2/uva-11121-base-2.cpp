// uva-11121-base-2.cpp : 定义控制台应用程序的入口点。
//n mod -2 余数可能为-1,0,1，但是不能出现-1，只能有0，1所以将-1变为1
/*
看一个10进制转2进制，例子1024
第0次迭代，1024/2=512,1024%2=0 , 试一下把512++变为513，那么逆回去就是1026，多了2，其实就是2^1
第1次迭代，512/2=256，512%2=0，试一下把256++变为257，那么逆回去，就是1028，多了4，其实就是2^2
在第i次迭代后商+1，其实相当于原来的数增加了2^(i+1)

n = b0 + b1(-2) + b2(-2)2 + b3(-2)3 + ...
当n为正数的时候，第i次迭代的时候余数为-1的话，那么i一定是奇数（因为余数为正为负只和n的正负有关,而n的正负在除-2的过程中是交替变化的，很容易可以知道当i为奇数的时候，n是负数或0，余数是-1或0）
那么对应的位置就应该是 -1*(-2)^i=2^i  ，如果变为1，则是1*(-2)^i=-2^i ,所以变为1后相当于减少了2*2^i=2^(i+1)
减少了的要加回来啊，怎么加，就在第i次迭代后的商+1，上面说了，第i次迭代后商+1，相当于逆回去加了2^(i+1)
所以以这个商继续迭代下去，最后得到的-2进制数就会等于原来的n

同理，当n为负数的时候，也是一样的分析
*/

#include "stdafx.h"
#include <cstdio>
#include <iostream>
#include <string.h>
#include <math.h>
#include <vector>
#include<iomanip>
#include <ctype.h>
#include <climits>  
#include <algorithm>
using namespace std;
#define N 110
int a[N];
int n;
int main()
{
    int t,T;
    scanf("%d",&T);
    for(int t=1; t<=T; t++)
    {
        scanf("%d",&n);
        int c=-1; a[0]=0;
        while(n)
        {
            a[++c]=n%(-2);//计算余数
            n=n/(-2);//商
            if(a[c]==-1)//余数-1应变为+1 相当于结果减去了2^(i+1)，故应于结果上加2^(i+1)，因此将商+1
            { a[c]=1; n++; }//第i次迭代后商+1，其实相当于原来的数增加了2^(i+1)
        }
        printf("Case #%d: ",t);
        while(c>0) printf("%d",a[c--]);
        printf("%d",a[0]);
        printf("\n");
    }
    return 0;
}

